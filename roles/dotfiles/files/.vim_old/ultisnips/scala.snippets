################################################################
#                        Scala snippets                        #
################################################################

snippet "im(port)?" "Import, with optional enumerations" br
import ${1:packages}
endsnippet

snippet "pkg" "Package" br
package ${1:packages}
endsnippet

snippet "package" "Package" br
package ${1:packages}
endsnippet

#if
snippet if "if" b
if (${1:cond}) {
	${0:/* if bloc */}
}
endsnippet

#if not
snippet ifn "ifn" b
if (!${1:cond}) {
	${0:/* if bloc */}
}
endsnippet

#if-else
snippet ifel "ifel" b
if (${1:cond}) {
	${2:/* if bloc */}
} else {
	${3:/* else bloc */}
}
endsnippet

#if-else-if
snippet ifelif "ifelif" b
if (${1:cond}) {
	${2:/* if bloc */}
} else if (${3:cond}) {
	${4:/* else if bloc */}
}
endsnippet

#while loop
snippet while "while" b
while (${1:cond}) {
	${2:/* while bloc */}
}
$0
endsnippet

#for loop(classic)
snippet for "for" b
for (${1:var} <- ${2:exp}) {
	$3
}
$0
endsnippet

#for loop(indexed)
snippet fori "fori" b
for (${1:i} <- ${2:0} to ${3:obj}.length) {
	$4
}
$0
endsnippet

#for loop(range to)
snippet forto "forto" b
for (${1:i} <- ${2:0} to ${3:10}) {
	$4
}
$0
endsnippet

#for loop(range until)
snippet forun "forun" b
for (${1:i} <- ${2:0} until ${3:10}) {
	$4
}
$0
endsnippet

#exceptions
snippet try "try"
try {
	${1:/* code */}
} catch {
	case e: ${2} => ${3:/* code */}
}
endsnippet

#exceptions
snippet tryf "try"
try {
	${1:/* code */}
} catch {
	case e: ${2} => ${3:/* code */}
} finally {
	${4:/* code */}
}
endsnippet

#match
snippet match "match"
${1:exp} match {
	case ${2:val} => ${3:/* code */}
}
endsnippet

#case
snippet case "case"
case ${1:val} => $0
endsnippet

############################
# methods and arguments
#
#arg
snippet arg "arg" i
${1:a}: ${2:T}${3:, arg}
endsnippet

#targ
snippet targ "type arg" i
${1:T}${2:, targ}
endsnippet

#args
snippet args "args" i
${1:args}: ${2:T}*
endsnippet

#type def
snippet tdef "type def" b
def ${1:name}[${2:T}](${3:arg}) = {
	${4}
}
$0
endsnippet

#def
snippet def "def" b
def ${1:name}(${2:arg}) = {
	${3}
}
$0
endsnippet

#private def
snippet prdef "prdef" b
private def ${1:name}(${2:arg}) = ${0:/* code */}
endsnippet

#override def
snippet ovdef "ovdef" b
override def ${1:name}(${2:arg}): ${3:T} = {
	${4:}
}
$0
endsnippet

#first class function(see scalabook p 188)
snippet fcf "fcf"
(${1:a}: ${2:T}) => $1 ${3:/* code */}
endsnippet

snippet => "=>"
${1:name} => ${0:/* code */}
endsnippet

#main method
#check validity of T
snippet main "main"
def main(args: Array[String]): Unit = {
	${0}
}
endsnippet

snippet array "Array"
Array[${1:T}]${2:(values)}
endsnippet

snippet map "map"
Map[${1:T}, ${2:T}]${3:(keyval)}
endsnippet

snippet hmap "hmap"
HashMap[${1:T}, ${2:T}]${3:(keyval)}
endsnippet

snippet mmap "mmap"
mutable.Map[${1:T}, ${2:T}]${3:(keyval)}
endsnippet

snippet mhmap "mhmap"
mutable.HashMap[${1:T}, ${2:T}]${3:(keyval)}
endsnippet

#TODO add TreeMap and TreeSet
#asInstanceOf[]
snippet as "as"
${1:name}.asInstanceOf[${0:T}]
endsnippet

#isInstanceOf[]
#end
#collections methods
#scope() with one arg
snippet (a "(a"
(${1:a} => ${0:/* code */})
endsnippet

#scope() with two args
snippet {( "{("
{(${1:a}, ${2:b}) =>
	${0:/* code */}
}
endsnippet

#filter
snippet filter "filter"
${1:name}.filter (a
endsnippet

#map function
snippet mapf "mapf"
${1:name}.map (a
endsnippet

#flatmap
snippet flatmap "flatmap"
${1:name}.flatMap${2:[T]}(a
endsnippet

#fold left
snippet fldl "fldl"
${1:name}.foldLeft(${2:first}) {(
endsnippet

#fold right
snippet fldr "fldr"
${1:name}.foldRight(${2:first}) {(
endsnippet

#fold left operator(if u wanna reduce readability of ur code)
#use wildcard symbols
snippet /: "/:"
(${1:first}/:${2:name})(${3:/* code */})
endsnippet

#fold right operator
snippet :\ ":\"
(${1:first}:\${2:name})(${3:/* code */})
endsnippet

#reduce left
snippet redl "redl"
${1:name}.reduceLeft[${2:T}] {(
endsnippet

#reduce right
snippet redr "redr"
${1:name}.reduceRight[${2:T}] {(
endsnippet

#zipWithIndex(safe way).
#see http://daily-scala.blogspot.com/2010/05/zipwithindex.html
snippet zipwi "zipwi"
${1:name}.view.zipWithIndex
endsnippet

#split
snippet spl "spl"
${1:name}.split("${2:,}")
endsnippet

#end
snippet val "val"
val ${1:name}${2:: T} = ${3:value}
endsnippet

snippet prval "private val"
private val ${1:name}${2:: T} = ${3:value}
endsnippet

snippet var "var"
var ${1:name}${2:: T} = ${3:value}
endsnippet

############################
# classes
#
#extends
snippet extends "extends"
extends ${1:what}
endsnippet

#with
snippet with "with"
with ${1:what}${2: with}
endsnippet

#auxiliary constructor(a. this)
snippet athis "athis"
def this(arg) = this(arg)
endsnippet

#abstract class
snippet abstract "abstract"
abstract class ${1:name} {
	${2:}
}
$0
endsnippet

#class
snippet class "class"
class ${1:name}${2:(arg)} {
	${3:}
}
$0
endsnippet

#object
snippet object "object"
object ${1:name} {
	${2:/* obj code here */}
}
$0
endsnippet

#trait
snippet trait "trait"
trait ${1:name} {
	$2
}
$0
endsnippet

#class with trait Ordered(page 265)
snippet ordered "ordered"
class ${1:name}${2:(arg)} extends Ordered[$1]${3: with} {
	${4:override def toString = "$1"}
	def compare(that: $1) = ${5:this - that}
	${6:/* code */}
}
endsnippet

#case class
snippet casecl "casecl"
case class ${1:name}(${2:arg})${3: extends ${4}${5: with ${5}}}
endsnippet

