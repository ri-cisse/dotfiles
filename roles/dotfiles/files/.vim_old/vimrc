if v:progname == 'vi'
  set noloadplugins
endif

" - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

" Initialize vim-plug and specify the path
" where the plugins should be installed.

" - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

let g:loaded_rrhelper = 1
let g:did_install_default_menus = 1  " avoid stupid menu.vim (saves ~100ms)

" Stop annoying paren match highlighting from flashing all over the screen.
let g:loaded_matchparen = 1

let g:rainbow_active = 1

call plug#begin('~/.vim/plugged')
  Plug 'NLKNguyen/papercolor-theme'

  " Plug 'vimwiki/vimwiki'

  " Plug 'gilsondev/searchtasks.vim'

  " Plug 'brooth/far.vim'

  " Plug 'machakann/vim-highlightedyank'

  Plug 'DataWraith/auto_mkdir'

  Plug 'alvan/vim-closetag'

  Plug 'duggiefresh/vim-easydir'

  " Plug 'Chiel92/vim-autoformat'

  Plug 'itchyny/vim-parenmatch'

  Plug 'vim-scripts/gitignore'

  Plug 'tpope/vim-unimpaired'

  " Plug 'jparise/vim-graphql', { 'for': [ 'graphql' ] }

  Plug 'haya14busa/incsearch.vim'
  Plug 'junegunn/vim-slash'
  Plug 'kristijanhusak/vim-dirvish-git'

  Plug 'kana/vim-textobj-user'
  Plug 'kana/vim-textobj-entire' " ae, ie
  Plug 'kana/vim-textobj-indent' " ai, ii
  Plug 'kana/vim-textobj-line'   " al, il
  " Plug 'glts/vim-textobj-comment' " ac, ic

  Plug 'coderifous/textobj-word-column.vim' " ic, ac, iC, and aC or vic, cic, and daC

  Plug 'mattn/vim-textobj-url' " au, iu
  " Plug 'saihoooooooo/vim-textobj-space' " aS, iS

  " Plug 'thinca/vim-textobj-function-javascript', { 'for': [ 'javascript', 'javascript.jsx' ] } | Plug 'kana/vim-textobj-function' " af, if

  Plug 'pangloss/vim-javascript', { 'for': [ 'javascript', 'javascript.jsx' ] } | Plug 'mxw/vim-jsx', { 'for': [ 'javascript', 'javascript.jsx' ] }
  Plug 'elzr/vim-json', { 'for': [ 'json' ] }
  Plug 'benjifisher/matchit.zip'

  " Ag/Ack for project-wide searching
  Plug 'mileszs/ack.vim', { 'on': [ 'Ack' ] }

  " Plug 'henrik/vim-open-url' " gx

  Plug 'GEverding/vim-hocon', { 'for': [ 'conf' ] }

  " Plug 'editorconfig/editorconfig-vim'

  Plug 'JulesWang/css.vim', { 'for': [ 'haml', 'scss', 'sass' ] }
  Plug 'ap/vim-css-color'
  Plug 'tpope/vim-haml', { 'for': [ 'haml', 'scss', 'sass' ] }
  Plug 'mattn/emmet-vim', { 'for': [ 'html', 'css', 'javascript', 'javascript.jsx' ] }

  Plug 'mattn/webapi-vim'
  Plug 'othree/html5.vim'
  Plug 'plasticboy/vim-markdown', { 'for': [ 'markdown' ] }
  Plug 'raimondi/delimitmate'
  Plug 'airblade/vim-gitgutter'
  Plug 'SirVer/ultisnips'
  Plug 'tomtom/tcomment_vim'
  Plug 'tpope/vim-fugitive'
  Plug 'junegunn/gv.vim', { 'on': [ 'GV' ] }
  Plug 'tpope/vim-repeat'
  Plug 'tpope/vim-surround'

  Plug 'vim-airline/vim-airline' | Plug 'vim-airline/vim-airline-themes'

  if has('nvim')
    " Plug 'roxma/nvim-completion-manager'
    " Plug 'roxma/nvim-cm-tern',  {'do': 'npm install'}

    " Plug 'fgrsnau/ncm-otherbuf'

    " Java completion
    " Plug 'sassanh/nvim-cm-eclim', { 'for': [ 'java' ] }

    " Plug 'autozimu/LanguageClient-neovim', {
    "       \ 'branch' : 'next',
    "       \ 'do'     : 'bash install.sh'
    "       \ }

    Plug 'Shougo/echodoc.vim'
  endif

  " Plug 'prabirshrestha/asyncomplete.vim'
  " " Plug 'prabirshrestha/vim-lsp'
  " " Plug 'prabirshrestha/asyncomplete-lsp.vim'
  " Plug 'prabirshrestha/asyncomplete-buffer.vim'
  " Plug 'prabirshrestha/asyncomplete-file.vim'
  " Plug 'prabirshrestha/asyncomplete-ultisnips.vim'
  " Plug 'prabirshrestha/async.vim'

  " Plug 'natebosch/vim-lsc'
  Plug 'neoclide/coc.nvim', {'branch': 'release'}
  " Plug 'neoclide/coc.nvim', {'branch': 'release', 'do': 'yarn install --frozen-lockfile'}
  " Plug 'scalameta/coc-metals', {'do': 'yarn install --frozen-lockfile'}

  " Plug 'wakatime/vim-wakatime'

  Plug 'tommcdo/vim-lion' " Align: gl, gL

  Plug 'derekwyatt/vim-scala', { 'for': [ 'scala' ] }

  Plug 'elmcast/elm-vim', { 'for': [ 'elm' ] }

  Plug 'ryanoasis/vim-webdevicons'

  " Plug 'glacambre/firenvim', { 'do': { _ -> firenvim#install(0) } }

  Plug 'pearofducks/ansible-vim', { 'for': [ 'yaml', 'ansible' ] }

  Plug 'mhinz/vim-startify'

  Plug 'tpope/vim-eunuch' " :SudoWrite, ...

  " Plug 'AndrewRadev/splitjoin.vim' " gJ, gS
  Plug 'FooSoft/vim-argwrap', { 'on': [ 'ArgWrap' ] }

  " Plug 'tmux-plugins/vim-tmux-focus-events'
  " Plug 'tmux-plugins/vim-tmux', { 'for': [  'tmux' ] }

  Plug 'ekalinin/Dockerfile.vim', { 'for' : 'Dockerfile' }
  Plug 'fatih/vim-nginx' , { 'for' : 'nginx' }

  Plug 'skywind3000/asyncrun.vim'

  Plug 'matze/vim-move' " <c-k>, <c-j>

  " Plug 'wincent/vim-clipper'

  if has('nvim')
    Plug 'kassio/neoterm'
  endif

  Plug 'luochen1990/rainbow'
  Plug 'google/vim-searchindex'
  Plug 'psliwka/vim-smoothie'

  Plug 'vim-scripts/ReplaceWithRegister' "replace <motion> with register

  " Plug 'mhartington/nvim-typescript', { 'for': ['typescript'] }
  " Plug 'HerringtonDarkholme/yats.vim', { 'for': ['typescript'] }
  " Plug 'mhartington/nvim-typescript', {'build': './install.sh'}
  " Plug 'leafgarland/typescript-vim', { 'for': [ 'typescript' ] }

  Plug 'Quramy/vim-js-pretty-template', { 'for': [ 'javascript', 'javascript.jsx' ] }

  " Plug 'flowtype/vim-flow', { 'for': [ 'javascript', 'javascript.jsx' ] }

  " Plug 'rust-lang/rust.vim', { 'for': [ 'rust' ] } | Plug 'racer-rust/vim-racer', { 'for': [ 'rust' ] } | Plug 'roxma/nvim-cm-racer', { 'for': [ 'rust' ] }

  " Plug 'kewah/vim-stylefmt', { 'for': [ 'sass', 'scss', 'css' ] }

  Plug 'christoomey/vim-sort-motion' " gs, gss

  " Plug 'zah/nim.vim', { 'for': [ 'nim' ] }

  " Plug 'dart-lang/dart-vim-plugin', { 'for': [ 'dart' ] }

  Plug 'kepbod/quick-scope'

  Plug 'tommcdo/vim-exchange' " cx

  " fzf greatness (fuzzy finding)
  Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --bin --no-update-rc --64 --key-bindings --completion' }
  Plug 'junegunn/fzf.vim'

  Plug 'justinmk/vim-dirvish'

  " Plug 'roxma/vim-paste-easy'

  "Plug 'ensime/ensime-vim', { 'for': ['scala'], 'do': ':UpdateRemotePlugins' }

  " Plug 'terryma/vim-expand-region', { 'on': [ '<Plug>(expand_region_expand)', '<Plug>(expand_region_shrink)' ] } " M-+, M--

  " Plug 'christoomey/vim-tmux-navigator', { 'on': [ 'TmuxNavigateLeft', 'TmuxNavigateRight', 'TmuxNavigatePrevious', 'TmuxNavigateUp', 'TmuxNavigateDown' ] }

  " Plug 'w0ng/vim-hybrid'
  " Plug 'chriskempson/base16-vim'
  " Plug 'challenger-deep-theme/vim'

  " Plug 'tpope/vim-projectionist', { 'on': ['A', 'AS', 'AV', 'AT'] }

  " Plug 'aklt/plantuml-syntax', { 'for': ['plantuml'] }

  " Plug 'artur-shaik/vim-javacomplete2', { 'for': ['java'] }

  " Plug 'w0rp/ale'

  " Plug 'easymotion/vim-easymotion'

  " Plug 'MattesGroeger/vim-bookmarks'

  " Plug 'alx741/vim-hindent', { 'for': ['haskell'] }
call plug#end()

" ----------------------------------------------------------------------
" | General Settings                                                   |
" ----------------------------------------------------------------------

" Use a different mapleader (default is '\').

let mapleader="\<Space>"
let maplocalleader="\\"

" set termencoding=utf-8
scriptencoding utf-8

if has('termguicolors')
  set termguicolors
endif

if has('termguicolors')
  " Don't need this in xterm-256color, but do need it inside tmux.
  " (See `:h xterm-true-color`.)
  if &term =~# 'tmux-256color'
    let &t_8f="\e[38;2;%ld;%ld;%ldm"
    let &t_8b="\e[48;2;%ld;%ld;%ldm"
  endif
endif

" Live substitution
if exists('&inccommand')
  set inccommand=split
endif

" Vim usable (these are default on NeoVim)
if !has('nvim')
  set nocompatible
  filetype off

  if has('autocmd')
    filetype plugin indent on
    "           │     │    └──── Enable file type detection.
    "           │     └───────── Enable loading of indent file.
    "           └─────────────── Enable loading of plugin files.
  endif

  set ttyfast
  set ttyscroll=3

  set laststatus=2

  if has('vim_starting')
    set encoding=utf-8 nobomb              " Set default encoding to UTF-8
  endif

  set autoindent
  set backspace=indent,eol,start  " Makes backspace key more powerful.
  set incsearch                   " Shows the match while typing
  set hlsearch                    " Highlight found searches
  set mouse=a
  if has('mouse_sgr')
    set ttymouse=sgr
  else
    set ttymouse=xterm2
  endif
else

  set mouse=a
endif

if exists('$SUDO_USER')
  set nobackup                        " don't create root-owned files
  set nowritebackup                   " don't create root-owned files
else
  set backupdir=~/.vim/tmp/backup   " Set directory for backup files.
endif

set backupskip=/tmp/*               " ┐ Don't create backups
set backupskip+=/private/tmp/*      " ┘ for certain files.

if exists('&belloff')
  set belloff=all                     " never ring the bell for any reason
endif

if has('clipboard')
  "http://stackoverflow.com/questions/20186975/vim-mac-how-to-copy-to-clipboard-without-pbcopy
  set clipboard^=unnamed
  set clipboard^=unnamedplus
end

set cpoptions+=$               " When making a change, don't
                               " redisplay the line, and instead,
                               " put a `$` sign at the end of
                               " the changed text.

if exists('+colorcolumn')
  " Highlight at textwidth and from 80 + 40 columns (this is the current Vim max) beyond 'textwidth'
  " let &l:colorcolumn="80," . join(map(range(40,999), '"+" . v:val'), ',')
endif

set cursorline                 " Highlight the current line.
set cursorcolumn               " Highlight the current column.

set nostartofline              " Keep cursor on same column while scrolling

if exists('$SUDO_USER')
  set noswapfile                      " don't create root-owned files
else
  set directory=~/.vim/tmp/swap//  " Set directory for swap files.
endif

set history=1000               " Increase command line history.
set noignorecase                 " Don't ignore case in search patterns.

set incsearch                  " Highlight search pattern
                               " as it is being typed.

set lazyredraw                 " Do not redraw the screen while
                               " executing macros, registers
                               " and other commands that have
                               " not been typed.

if !has('nvim')
  syntax enable
  let &t_Co = 256
  set term=ansi

  " Make arrow keys work in vim
  imap <ESC>oA <ESC>ki
  imap <ESC>oB <ESC>ji
  imap <ESC>oC <ESC>li
  imap <ESC>oD <ESC>hi
endif

if has('gui_macvim')
  " No toolbars, menu or scrollbars in the GUI
  set guifont=Sauce\ Code\ Pro\ Nerd\ Font\ Complete:h12
  set clipboard+=unnamed
  set vb t_vb=
  set guioptions-=m  "no menu
  set guioptions-=T  "no toolbar
  set guioptions-=l
  set guioptions-=L
  set guioptions-=r  "no scrollbar
  set guioptions-=R
endif

if has('linebreak')
  set breakindent                     " indent wrapped lines to match start
  if exists('&breakindentopt')
    set breakindentopt=shift:2        " emphasize broken lines by indenting them
  endif
endif

set magic                      " Enable extended regexp.
set mousehide                  " Hide mouse pointer while typing.
set noerrorbells               " Disable error bells.

set nojoinspaces               " When using the join command,
                               " only insert a single space
                               " after a `.`, `?`, or `!`.

set nostartofline              " Kept the cursor on the same column.
set number                     " Show line number.

set numberwidth=4              " Increase the minimal number of
                               " columns used for the `line number`.

set report=100                 " Report the number of lines changed.
set ruler                      " Show cursor position.

set scrolloff=1                " When scrolling, keep the cursor
                               " 5 lines below the top and 5 lines
                               " above the bottom of the screen.

set sidescrolloff=5            " same as scolloff, but for columns

set display+=lastline

if has('linebreak')
  let &showbreak='⤷ '          " ARROW POINTING DOWNWARDS THEN CURVING RIGHTWARDS (U+2937, UTF-8: E2 A4 B7)
endif

" Avoid all the hit-enter prompts.
set shortmess+=A                 " ignore annoying swapfile messages
set shortmess+=I                 " no splash screen
set shortmess+=O                 " file-read message overwrites previous
set shortmess+=T                 " truncate non-file messages in middle
set shortmess+=W                 " don't echo "[w]"/"[written]" when writing
set shortmess+=a                 " use abbreviations in messages eg. `[RO]` instead of `[readonly]`
set shortmess+=o                 " overwrite file-written messages
set shortmess+=t                 " truncate file messages at start

" don't give |ins-completion-menu| messages.  For example,
" '-- XXX completion (YYY)', 'match 1 of 2', 'The only match',
try
  set shortmess+=c
catch
endtry

if has('showcmd')
  set showcmd                    " Show the command being typed.
endif

set showmode                   " Show current mode.
set spelllang=en_us            " Set the spellchecking language.

set smartcase                  " Override `ignorecase` option
                               " if the search pattern contains
                               " uppercase characters.

set infercase                   " Smarter case during autocompletion.

set synmaxcol=2500             " Limit syntax highlighting (this
                               " avoids the very slow redrawing
                               " when files contain long lines).

set tabstop=2                  " ┐
set shiftround                 " │ Set global <TAB> settings.
set shiftwidth=2               " │
set expandtab                  " ┘

if v:progname !=# 'vi'
  set softtabstop=-1           " use 'shiftwidth' for tab/bs at end of line
endif

if has('persistent_undo')
  if exists('$SUDO_USER')
    set noundofile                    " don't create root-owned files
  else
    set undodir+=~/.vim/tmp/undo      " keep undo files out of the way
    set undofile                      " actually use undo files
  endif
endif

set visualbell                 " ┐
set noerrorbells               " │ Disable beeping and window flashing
set t_vb=                      " ┘ https://vim.wikia.com/wiki/Disable_beeping


set wildmenu                   " Enable enhanced command-line
                               " completion (by hitting <TAB> in
                               " command mode, Vim will show the
                               " possible matches just above the
                               " command line with the first
                               " match highlighted).

set wildmode=longest:full,full        " shell-like autocomplete to unambiguous portion

set wildcharm=<C-z>            " substitue for 'wildchar' (<Tab>) in macros

set wildignore+=*/tmp/*,*.swp   " Ignored files

set winminheight=0             " Allow windows to be squashed.

if has('folding')
  if has('windows')
    set fillchars=vert:┃              " BOX DRAWINGS HEAVY VERTICAL (U+2503, UTF-8: E2 94 83)
  endif
  set foldenable                      " enable folding
  set foldmethod=indent               " not as cool as syntax, but faster
  set foldlevelstart=99               " start unfolded

  " set foldtext=FoldText()
  " function! FoldText()
  "   let l:lpadding = &fdc
  "   redir => l:signs
  "   execute 'silent sign place buffer='.bufnr('%')
  "   redir End
  "   let l:lpadding += l:signs =~ 'id=' ? 2 : 0
  "
  "   if exists("+relativenumber")
  "     if (&number)
  "       let l:lpadding += max([&numberwidth, strlen(line('$'))]) + 1
  "     elseif (&relativenumber)
  "       let l:lpadding += max([&numberwidth, strlen(v:foldstart) + strlen(v:foldstart - line('w0')), strlen(v:foldstart) + strlen(line('w$') - v:foldstart)]) + 1
  "     endif
  "   else
  "     if (&number)
  "       let l:lpadding += max([&numberwidth, strlen(line('$'))]) + 1
  "     endif
  "   endif
  "
  "   " expand tabs
  "   let l:start = substitute(getline(v:foldstart), '\t', repeat(' ', &tabstop), 'g')
  "   let l:end = substitute(substitute(getline(v:foldend), '\t', repeat(' ', &tabstop), 'g'), '^\s*', '', 'g')
  "
  "   let l:info = ' (' . (v:foldend - v:foldstart) . ')'
  "   let l:infolen = strlen(substitute(l:info, '.', 'x', 'g'))
  "   let l:width = winwidth(0) - l:lpadding - l:infolen
  "
  "   let l:separator = ' … '
  "   let l:separatorlen = strlen(substitute(l:separator, '.', 'x', 'g'))
  "   let l:start = strpart(l:start , 0, l:width - strlen(substitute(l:end, '.', 'x', 'g')) - l:separatorlen)
  "   let l:text = l:start . ' … ' . l:end
  "
  "   return l:text . repeat(' ', l:width - strlen(substitute(l:text, ".", "x", "g"))) . l:info
  " endfunction
endif

set pumheight=10             " Completion window max size

if v:version > 703 || v:version == 703 && has('patch541')
  set formatoptions+=j                " remove comment leader when joining comment lines
endif

set formatoptions+=n                  " smart auto-indenting inside numbered lists

" indentation
set formatoptions+=w

set smartindent cinwords=if,elif,else,for,while,try,except,finally,def,class,func,fun,fn,interface,trait " auto indent on these words

if has('linebreak')
  set linebreak                       " wrap long lines at characters in 'breakat'
endif

" ----------------------------------------------------------------------
" | Plugins - Emmet                                                    |
" ----------------------------------------------------------------------

" Redefine trigger key for Emmet.
" http://docs.emmet.io/cheat-sheet/

" let g:user_emmet_leader_key="<C-E>"

let g:user_emmet_install_global = 0
autocmd FileType html,css,javascript,javascript.jsx EmmetInstall

" - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

" Load custom Emmet snippets.
" http://docs.emmet.io/customization/snippets/

let g:user_emmet_settings = webapi#json#decode(join(readfile(expand("~/.vim/snippets/emmet.json")), "\n"))

" ----------------------------------------------------------------------
" | Plugins - Markdown                                                 |
" ----------------------------------------------------------------------

" Disable Folding.
" https://github.com/plasticboy/vim-markdown#disable-folding

let g:vim_markdown_folding_disabled=1

" - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

nnoremap <silent> <localleader>w :call mappings#leader#zap()<CR>

" ----------------------------------------------------------------------
" | Automatic Commands                                                 |
" ----------------------------------------------------------------------

if has('autocmd')

  " Autocommand Groups.
  " http://learnvimscriptthehardway.stevelosh.com/chapters/14.html

  " - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  " Automatically strip the trailing
  " whitespaces when files are saved.

  augroup strip_trailing_whitespaces

    " List of file types that use the trailing whitespaces:
    "
    "  * Markdown
    "    https://daringfireball.net/projects/markdown/syntax#block

    let excludedFileTypes = [
          \ "markdown",
          \ "mkd.markdown"
          \]

    " - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    " Only strip the trailing whitespaces if
    " the file type is not in the excluded list.

    autocmd!
    autocmd BufWritePre * if index(excludedFileTypes, &ft) < 0 | :call mappings#leader#zap()

  augroup END

endif

" Search and replace the word under the cursor.

" Replace all

nnoremap <leader>r :%s/\V\<<C-r>=autocmds#escape_pattern(expand('<cword>'))<CR>\>//c<Left><Left>
vnoremap <leader>r :<c-u>%s/\V<c-r>=autocmds#escape_pattern(autocmds#get_visual_selection())<CR>//c<Left><Left>

" - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

" Make the opening of the `.vimrc` file easier.

nnoremap <localleader>e :e $MYVIMRC<CR>
nnoremap <localleader>r :source $MYVIMRC<CR>

" - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

set hidden

" - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

if !has('nvim')
  set highlight+=c:LineNr               " blend vertical separators with line numbers
  " Sync with corresponding nvim settings in ~/.vim/plugin/autocmds.vim:
  set highlight+=@:ColorColumn        " ~/@ at end of window, 'showbreak'
  set highlight+=N:DiffText           " make current line number stand out a little
  set highlight+=c:LineNr             " blend vertical separators with line numbers

  hi! CocCursorRange guibg=#b16286 guifg=#ebdbb2
endif

" - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

" Don't continue comment mark after press 'o' when you're on a commented line.
autocmd FileType * setlocal formatoptions-=c formatoptions-=r formatoptions-=o

" Don't automatically break lines at textwidth
autocmd FileType * setlocal formatoptions-=t

" <Ctrl-l> redraws the screen and removes any search highlighting.
nnoremap <silent> <C-L> :nohlsearch<C-R>=has('diff')?'<Bar>diffupdate':''<CR><CR><C-L>

" toggle invisible characters
set list
set listchars=nbsp:⦸                  " CIRCLED REVERSE SOLIDUS (U+29B8, UTF-8: E2 A6 B8)
set listchars+=tab:▷┅                 " WHITE RIGHT-POINTING TRIANGLE (U+25B7, UTF-8: E2 96 B7)
                                      " + BOX DRAWINGS HEAVY TRIPLE DASH HORIZONTAL (U+2505, UTF-8: E2 94 85)
set listchars+=extends:»              " RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK (U+00BB, UTF-8: C2 BB)
set listchars+=precedes:«             " LEFT-POINTING DOUBLE ANGLE QUOTATION MARK (U+00AB, UTF-8: C2 AB)
set listchars+=trail:•                " BULLET (U+2022, UTF-8: E2 80 A2)

set completeopt-=preview    " Don't show preview window during completion.
set complete-=i

set smarttab                " tab respects 'tabstop', 'shiftwidth', and 'softtabstop

set textwidth=80               " automatically hard wrap at 80 columns

set showtabline=0

" For conceal markers.
if has('conceal')
  " set conceallevel=1
endif

" VIM jsx

" Conceal some characters in javascript

" let g:javascript_conceal_function       = "ƒ"
" let g:javascript_conceal_null           = "ø"
" let g:javascript_conceal_this           = "@"
" let g:javascript_conceal_return         = "⇚"
" let g:javascript_conceal_undefined      = "¿"
" let g:javascript_conceal_NaN            = "ℕ"
" let g:javascript_conceal_prototype      = "¶"
" let g:javascript_conceal_static         = "•"
" let g:javascript_conceal_super          = "Ω"
" let g:javascript_conceal_arrow_function = "⇒"

let g:jsx_ext_required = 0
let g:javascript_plugin_flow = 1

function! s:SetColorScheme()
  " colorscheme challenger_deep
  " set background=dark

  set background=light
  colorscheme PaperColor

  " hi! Normal guibg=#000
  hi! VertSplit guifg=#fff
  hi! CursorLineNr gui=bold guifg=NONE guibg=NONE

  hi! Search guifg=#969896 guibg=#f0c674
  hi! IncSearch guifg=#282a2e guibg=#de935f
  " hi! PMenu guifg=#c5c8c6 guibg=#282a2e
  hi! PMenuSel guifg=#282a2e guibg=#c5c8c6
  hi! Pmenu guibg='00010a' guifg=white

  " if !has('termguicolors')
  "   let g:base16colorspace=256
  " endif
  "
  " let s:config_file = expand('~/.base16')
  "
  " if filereadable(s:config_file)
  "   let s:config = readfile(s:config_file, '', 2)
  "
  "   if s:config[1] =~# '^dark\|light$'
  "     execute 'set background=' . s:config[1]
  "   else
  "     echoerr 'Bad background ' . s:config[1] . ' in ' . s:config_file
  "   endif
  "
  "   if filereadable(expand('~/.vim/plugged/base16-vim/colors/base16-' . s:config[0] . '.vim'))
  "     execute 'colorscheme base16-' . s:config[0]
  "   elseif filereadable(expand('~/.vim/plugged/base16-vim/colors/base16-' . s:config[0] . '-' . s:config[1] . '.vim'))
  "     execute 'colorscheme base16-' . s:config[0] . '-' . s:config[1]
  "   else
  "     echoerr 'Bad scheme ' . s:config[0] . ' in ' . s:config_file
  "   endif
  " else " default
  "   set background=dark
  "   colorscheme base16-ocean
  " endif

  " let g:hybrid_custom_term_colors = 1
  " let g:hybrid_reduced_contrast = 1 " Remove this line if using the default palette.
  let g:airline_theme='hybridline'
  " set background=dark
  " colorscheme hybrid

  " Highlighting function
  " fun! <sid>hi(group, guifg, guibg, ctermfg, ctermbg, attr, guisp)
  "   if a:guifg != ""
  "     exec "hi " . a:group . " guifg=#" . a:guifg
  "   endif
  "   if a:guibg != ""
  "     exec "hi " . a:group . " guibg=#" . a:guibg
  "   endif
  "   if a:ctermfg != ""
  "     exec "hi " . a:group . " ctermfg=" . a:ctermfg
  "   endif
  "   if a:ctermbg != ""
  "     exec "hi " . a:group . " ctermbg=" . a:ctermbg
  "   endif
  "   if a:attr != ""
  "     exec "hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
  "   endif
  "   if a:guisp != ""
  "     exec "hi " . a:group . " guisp=#" . a:guisp
  "   endif
  " endfun

  " call <sid>hi("ColorColumn", "", "282a2e", "", "282a2e", "none", "")

  " highlight link ColorColumn CursorLine
  " highlight link EndOfBuffer ColorColumn
  " highlight link CursorLineNr ColorColumn
  highlight LineNr guibg=#000
  highlight GitGutterAdd guibg=#000
  highlight GitGutterChange guibg=#000
  highlight GitGutterDelete guibg=#000
  highlight GitGutterChangeDelete guibg=#000

  " Make tildes at EndOfBuffer less obvious.
  " let l:prefix=has('gui') || has('termguicolors') ? 'gui' : 'cterm'
  " let l:bg=synIDattr(synIDtrans(hlID('ColorColumn')), 'bg', l:prefix)
  " let l:fg=l:bg
  " execute 'highlight EndOfBuffer ' . l:prefix . 'fg=' . l:fg . ' ' . l:prefix . 'bg=' . l:bg
  " execute 'highlight CursorLineNr ' . l:prefix . 'bg=' . l:bg . ' '. l:prefix.'=bold'

  " make the highlighting of tabs and other non-text less annoying
  " highlight SpecialKey ctermbg=none ctermfg=8
  " highlight NonText ctermfg=8 ctermbg=none

  " make comments and HTML attributes italic
  highlight! Comment cterm=italic  gui=italic
  highlight! htmlArg cterm=italic  gui=italic

  " hi Search guifg=#ffffff guibg=#1B5E20 gui=none
  " hi IncSearch guifg=#ffffff guibg=#66BB6A gui=none

  " hi VisualNOS gui=bold,underline
  " highlight! link Search VisualNOS
  " highlight! link IncSearch VisualNOS

  " highlight! link QuickFixLine PmenuSel

  let &t_ZH="^[[3m"
  let &t_ZR="^[[23m"

  " Allow for overrides:
  " - `statusline.vim` will re-set User1, User2 etc.
  " - `after/plugin/loupe.vim` will override Search.
  " doautocmd ColorScheme
endfunction

if v:progname !=# 'vi'
  " if has('autocmd')
  "   augroup AmsaykAutocolor
  "     autocmd!
  "     autocmd FocusGained * call s:CheckColorScheme()
  "   augroup END
  " endif

  call s:SetColorScheme()
endif

" Make arrows and some other keys work inside TMUX
if exists('$TMUX')
  execute "set <xUp>=\e[1;*A"
  execute "set <xDown>=\e[1;*B"
  execute "set <xRight>=\e[1;*C"
  execute "set <xLeft>=\e[1;*D"
  execute "set <xHome>=\e[1;*H"
  execute "set <xEnd>=\e[1;*F"
  execute "set <Insert>=\e[2;*~"
  execute "set <Delete>=\e[3;*~"
  execute "set <PageUp>=\e[5;*~"
  execute "set <PageDown>=\e[6;*~"
  execute "set <xF1>=\e[1;*P"
  execute "set <xF2>=\e[1;*Q"
  execute "set <xF3>=\e[1;*R"
  execute "set <xF4>=\e[1;*S"
  execute "set <F5>=\e[15;*~"
  execute "set <F6>=\e[17;*~"
  execute "set <F7>=\e[18;*~"
  execute "set <F8>=\e[19;*~"
  execute "set <F9>=\e[20;*~"
  execute "set <F10>=\e[21;*~"
  execute "set <F11>=\e[23;*~"
  execute "set <F12>=\e[24;*~"
endif

" ----------------------------------------------------------------------------
" Readline-style key bindings in command-line (excerpt from rsi.vim)
" ----------------------------------------------------------------------------
cnoremap        <C-A> <Home>
cnoremap        <C-B> <c-Left>
cnoremap        <C-G> <c-Right>
cnoremap <expr> <C-D> getcmdpos()>strlen(getcmdline())?"\<Lt>C-D>":"\<Lt>Del>"
cnoremap <expr> <C-F> getcmdpos()>strlen(getcmdline())?&cedit:"\<Lt>Right>"

" Align current paragraph
nmap <leader>F :call mappings#leader#format#align()<CR>
vmap <leader>F =

" Kill double quotes
nmap <c-s>" :%s/\V\"/'<CR><C-L>
nmap <c-s>' :%s/\V\'/"<CR><C-L>

" Elm

let g:elm_jump_to_error = 1
let g:elm_make_output_file = 'elm.js'
let g:elm_make_show_warnings = 0
let g:elm_syntastic_show_warnings = 0
let g:elm_browser_command = ""
let g:elm_detailed_complete = 0
let g:elm_format_autosave = 1
let g:elm_format_fail_silently = 0
let g:elm_setup_keybindings = 0

""""""""""""""""""""""" }}}
" Ctags                 {{{
"""""""""""""""""""""""

" nn <leader>g :AsyncRun git ctags<CR>

" set tags+=.git/tags

" Let me select my tags
" nnoremap <c-]> g<c-]>
" nnoremap g<c-]> <c-]>

" Open tag for word under cursor in a new vsplit
" map <c-\> :vsp<CR>:exec("tag ".expand("<cword>"))<CR>

if has('timers')
  " Blink 2 times with 50ms interval
  noremap <expr> <plug>(slash-after) slash#blink(2, 50)
endif

if has('autocmd')
  augroup AmsaykAutocmds
    autocmd!

    " Disable paste mode on leaving insert mode.
    autocmd InsertLeave * set nopaste

    autocmd VimResized * wincmd =

    " http://vim.wikia.com/wiki/Detect_window_creation_with_WinEnter
    autocmd VimEnter * autocmd WinEnter * let w:created=1
    autocmd VimEnter * let w:created=1

    " Make current window more obvious by turning off/adjusting some features in non-current
    " windows.
    if exists('+winhighlight')
      autocmd BufEnter,FocusGained,VimEnter,WinEnter * if autocmds#should_colorcolumn() | set winhighlight= | endif
      autocmd FocusLost,WinLeave * if autocmds#should_colorcolumn() | set winhighlight=CursorLineNr:LineNr,IncSearch:ColorColumn | endif
    elseif exists('+colorcolumn')
      autocmd BufEnter * if autocmds#should_colorcolumn() | let &l:colorcolumn='80' | endif
      " autocmd BufEnter,FocusGained,VimEnter,WinEnter * if autocmds#should_colorcolumn() | let &l:colorcolumn='80' | endif
      " autocmd BufEnter,FocusGained,VimEnter,WinEnter * if autocmds#should_colorcolumn() | let &l:colorcolumn='80,'.join(map(range(40,999), '"+" . v:val'), ',') | endif
      " autocmd FocusLost,WinLeave * if autocmds#should_colorcolumn() | let &l:colorcolumn=join(range(1, 999), ',') | endif
    endif

    autocmd InsertLeave,VimEnter,WinEnter * if autocmds#should_cursorline() | setlocal cursorline | endif
    autocmd InsertEnter,WinLeave * if autocmds#should_cursorline() | setlocal nocursorline | endif

    " if exists("*matchaddpos")
      autocmd BufEnter,FocusGained,VimEnter,WinEnter * call autocmds#focus_window()
      autocmd FocusLost,WinLeave * call autocmds#blur_window()
    " endif

    if has('mksession')
      " Save/restore folds and cursor position.
      autocmd BufWritePost,BufWinLeave,BufLeave,WinLeave ?* if autocmds#should_mkview() | call autocmds#mkview() | endif
      if has('folding')
        autocmd BufWinEnter ?* if autocmds#should_mkview() | silent! loadview | execute 'silent! ' . line('.') . 'foldopen!' | endif
      else
        autocmd BufWinEnter ?* if autocmds#should_mkview() | silent! loadview | endif
      endif
    elseif has('folding')
      " Like the autocmd described in `:h last-position-jump` but we add `:foldopen!`.
      autocmd BufWinEnter * if line("'\"") > 1 && line("'\"") <= line('$') | execute "normal! g`\"" | execute 'silent! ' . line("'\"") . 'foldopen!' | endif
    else
      autocmd BufWinEnter * if line("'\"") > 1 && line("'\"") <= line('$') | execute "normal! g`\"" | endif
    endif

    if has('nvim')
      " Sync with corresponding non-nvim settings in ~/.vim/plugin/settings.vim:
      " autocmd ColorScheme * highlight! link NonText ColorColumn
      " autocmd ColorScheme * highlight! link CursorLineNr DiffText
      " autocmd ColorScheme * highlight! link VertSplit LineNr
    endif

    autocmd BufWritePost */spell/*.add silent! :mkspell! %

    autocmd BufWritePost * call autocmds#encrypt(expand('<afile>:p'))

    if exists('+relativenumber')
      " show relative numbers in gutter when window is active
      autocmd FocusLost,WinLeave,BufWinLeave,InsertEnter * if autocmds#should_number() | setlocal norelativenumber | endif
      autocmd FocusGained,WinEnter,BufWinEnter,InsertLeave * if autocmds#should_number() | setlocal relativenumber | endif
    endif

    " Let's close the location and the quickfix window if it's the last one
    if exists('##QuitPre')
      autocmd QuitPre * if &filetype != 'qf' | silent! lclose | silent! cclose | endif
    endif

    " Close preview window
    if exists('##CompleteDone')
      au CompleteDone * pclose
    else
      au InsertLeave * if !pumvisible() && (!exists('*getcmdwintype') || empty(getcmdwintype())) | pclose | endif
    endif

    if exists('##TextYankPost')
      autocmd TextYankPost * silent! lua return (not vim.v.event.visual) and require'vim.highlight'.on_yank('Substitute', 200)
    endif
  augroup END

  " Wait until idle to run additional "boot" commands.
  augroup AmsaykIdleboot
    autocmd!
    if has('vim_starting')
      autocmd CursorHold,CursorHoldI * call autocmds#idleboot()
    endif
  augroup END
endif


" `<Tab>`/`<S-Tab>` to move between matches without leaving incremental search.
" Note dependency on `'wildcharm'` being set to `<C-z>` in order for this to
" work.
cnoremap <expr> <Tab> getcmdtype() == '/' \|\| getcmdtype() == '?' ? '<CR>/<C-r>/' : '<C-z>'
cnoremap <expr> <S-Tab> getcmdtype() == '/' \|\| getcmdtype() == '?' ? '<CR>?<C-r>/' : '<S-Tab>'

" Neovim enhancements

" Store relative line number jumps in the jumplist if they exceed a threshold.
nnoremap <expr> k (v:count > 5 ? "m'" . v:count : '') . 'k'
nnoremap <expr> j (v:count > 5 ? "m'" . v:count : '') . 'j'

" Make the jk behave

nnoremap j gj
nnoremap k gk

nnoremap gj j
nnoremap gk k

" Save all
nn <leader>s :wa<CR>

" Save current buffer
nn <leader>S :update<CR>

" Quickly quick current buffer
nn <leader>q :confirm q<CR>

" Close all
nn <leader>Q :confirm qall<CR>

" Always use vertical diffs
set diffopt+=vertical

" disable bracketed paste
set t_BE=0

" Relying on Karabiner-Elements to avoid collision between <Tab> and
" <C-i> (have it send F6 instead for <C-i>).
nnoremap <F6> <C-i>
inoremap <F6> <Tab>

" Avoid unintentional switches to Ex mode. This would be more useful.
nnoremap Q :normal n.<CR>

nnoremap Y y$

vnoremap y myy`y
vnoremap Y myY`y

" Backspace should delete selection and put me in insert mode

vnoremap <BS> "_xi

nn _ "_dd

" gf

" Open file under the cursor in a vsplit
nnoremap gf :rightbelow wincmd f<CR>

set suffixesadd=.js
set suffixesadd=.ts
set suffixesadd+=.json

set path+=*/**

set shell=/bin/sh

set updatetime=250

" always show signcolumns
set signcolumn=yes

" Better display for messages
set cmdheight=3

" ==================== delimitMate ====================
let g:delimitMate_expand_cr            = 1
let g:delimitMate_expand_space         = 1
let g:delimitMate_smart_quotes         = 1
let g:delimitMate_expand_inside_quotes = 0
let g:delimitMate_smart_matchpairs     = '^\%(\w\|\$\)'
let g:delimitMate_excluded_ft          = 'mail,txt'

augroup DelimitMate
  autocmd!

  let g:closetag_filenames = "*.xml,*.html,*.html,*.tsx,*.js,*.jsx,*.config"
  let g:closetag_emptyTags_caseSensitive = 1

  au FileType javascript,javascript.jsx,scala,vim let b:delimitMate_matchpairs = "(:),[:],{:}"
  au FileType html,rust,dart,java let b:delimitMate_matchpairs = "(:),[:],{:},<:>"
  au FileType python,java,dart let b:delimitMate_nesting_quotes = ['"']
  au FileType scala let b:delimitMate_nesting_quotes = ['"', '"""']
  au FileType rust let b:delimitMate_nesting_quotes = ['"', "|"]
  au FileType javascript,javascript.jsx let b:delimitMate_nesting_quotes = ['`']

  func! s:delimitMate_map() abort
    imap <buffer><expr> <C-Tab> delimitMate#JumpAny()
  endfunc

  func! s:delimitMate_unmap()
    silent! iunmap <buffer> <C-Tab>
  endfunction

  au User delimitMate_map call s:delimitMate_map()
  au User delimitMate_unmap call s:delimitMate_unmap()
augroup END

if exists('&swapsync')
  set swapsync=                       " let OS sync swapfiles lazily
endif
set switchbuf=usetab

set whichwrap=b,h,l,s,<,>,[,],~     " Allow <BS>/h/l/<Right>/<Space> to move cross line boundaries

if has('windows')
  set splitbelow                      " open horizontal splits below current window
endif

if has('vertsplit')
  set splitright                      " open vertical splits to the right of the current window
endif

if has('viminfo')
  if exists('$SUDO_USER')
    set viminfo=                      " don't create root-owned files
  else
    set viminfo+=n~/.vim/tmp/viminfo

    if !empty(glob('~/.vim/tmp/viminfo'))
      if !filereadable(expand('~/.vim/tmp/viminfo'))
        echoerr 'warning: ~/.vim/tmp/viminfo exists but is not readable'
      endif
    endif

  endif
endif

if has('mksession')
  set viewdir=~/.vim/tmp/view
  set viewoptions=cursor,folds        " save/restore just these (with `:{mk,load}view`)
  set sessionoptions=folds
endif

" <Leader><Leader> -- Open last buffer.
nnoremap <leader><leader> <C-^>

nnoremap <leader>o :only<CR>

" <LocalLeader>c -- Fix (most) syntax highlighting problems in current buffer
" (mnemonic: coloring).
nnoremap <silent> <localleader>c :syntax sync fromstart<CR>

syntax sync minlines=256 " start highlighting from 256 lines backwards
set synmaxcol=300        " do not highlith very long lines
set re=1                 " use explicit old regexpengine, seems to be more faster

" Time out on key codes but not mappings.
" Basically this makes terminal Vim work sanely.
if !has('gui_running')
  set notimeout
  set ttimeout
  set ttimeoutlen=10
  augroup FastEscape
    autocmd!
    au InsertEnter * set timeoutlen=0
    au InsertLeave * set timeoutlen=1000
  augroup END
endif

" Prevent tcomment from making a zillion mappings (we just want the operator).
let g:tcomment_mapleader1=''
let g:tcomment_mapleader2=''
let g:tcomment_mapleader_comment_anyway=''
let g:tcomment_textobject_inlinecomment=''

" The default (g<) is a bit awkward to type.
let g:tcomment_mapleader_uncomment_anyway='gu'

" Count occurences of word under cursor
nnoremap <leader>* *<C-O>:%s///gn<CR>

"" Git
"no mappings by gitgutter
let g:gitgutter_map_keys = 0

let g:gitgutter_max_signs = 1200

"focus window of last created buffer
function! JumpLastBufferWindow()
  call win_gotoid(win_getid(bufwinnr(last_buffer_nr())))
endfunction

nnoremap <c-g>b :Gblame<cr>
nnoremap <c-g>B :Gbrowse<cr>
nnoremap <c-g>s :Gstatus<cr>
" nnoremap <c-g>c :Gcommit<cr>
nnoremap <c-g>d :Gvdiff<cr>
nnoremap <c-g>P :Gpush<cr>
nnoremap <c-g>L :Gpull<cr>
" nnoremap <c-g>R :!git checkout <c-r>%<cr><cr>
nnoremap <c-g>p :GitGutterPreviewHunk<cr>:call JumpLastBufferWindow()<cr>
" nnoremap <c-g>r :GitGutterUndoHunk<cr>
nnoremap <c-g>S :GitGutterStageHunk<cr>
nnoremap <c-g>l :GitGutterLineHighlightsToggle<cr>
nnoremap [h :GitGutterPrevHunk<cr>
nnoremap ]h :GitGutterNextHunk<cr>

" let g:gitgutter_sign_added = '↪'
" let g:gitgutter_sign_removed = '↩'
" let g:gitgutter_sign_modified = '↬'
" let g:gitgutter_sign_modified_removed = '↫'

let g:gitgutter_sign_added = '┃'
let g:gitgutter_sign_removed = '┃'
let g:gitgutter_sign_modified = '┃'
let g:gitgutter_sign_modified_removed = '┃'

if has('virtualedit')
  set virtualedit=insert    " allow the cursor to go everywhere (insert)
  set virtualedit+=onemore  " allow the cursor to go just past the end of line
  set virtualedit+=block    " allow the cursor to go everywhere (visual block)
endif

" Convenient command to see the difference between the current buffer and the
" file it was loaded from, thus the changes you made.
" Only define it when not defined already.
if !exists(':DiffOrig')
  command DiffOrig vert new | set buftype=nofile | read ++edit # | 0d_ | diffthis
        \ | wincmd p | diffthis
endif

command! -bang -nargs=* -complete=file Make AsyncRun -program=make @ <args>

" Execute normal cmds multiple times
command! -count=1 -nargs=+ Normal for i in range(1,<count>) | exe 'normal ' . <q-args> | endfor

" Resize split easily
augroup ArrowKeys
  autocmd!

  function! s:ToggleArrowKeys() abort
    nn <buffer> <leader>= :execute "wincmd ="<CR>

    " map <expr> <M-+> "<Plug>(expand_region_expand)" " a-+
    " map <expr> <M--> "<Plug>(expand_region_shrink)" " a--
  endfunction

  autocmd BufWinEnter,WinEnter,BufLeave * call s:ToggleArrowKeys()
augroup end

set pastetoggle=<F3>

vnoremap . :norm.<CR>

" Folds
nmap <expr> <Tab> 'za'
nmap <expr> <S-Tab> 'za'

" vim-move

let g:move_key_modifier = 'C'
let g:move_map_keys = 0

vmap <C-j> <Plug>MoveBlockDown
nmap <C-j> <Plug>MoveLineDown

vmap <C-k> <Plug>MoveBlockUp
nmap <C-k> <Plug>MoveLineUp

" Search word under cursor
" nnoremap <leader>/ :Ag <C-r>=autocmds#escape_pattern(expand('<cword>'))<CR><Space> **/*.*
" vnoremap <leader>/ :<c-u>Ag <C-r>=autocmds#escape_pattern(autocmds#get_visual_selection())<CR><Space> **/*.*

if executable("rg")
  let g:ackprg = 'rg --vimgrep --smart-case'
  cnoreabbrev ag Ack!

  set grepprg=rg\ --no-heading\ --vimgrep\ --files\ --glob\ "!.git/*"\ --glob\ "!vendor/*"
  set grepformat=%f:%l:%c:%m
elseif executable("ag")
  let g:ackprg = 'ag --vimgrep --smart-case'
  cnoreabbrev ag Ack!

  " Use ag over grep
  set grepprg=ag\ --nogroup\ --nocolor
endif

" Ctrl-o: Go back in the jumplist, also realign the screen
nnoremap <c-o> <c-o>zzzv

" NeoTerm

if has('nvim')
  let g:neoterm_default_mod   = 'vertical'
  let g:neoterm_shell         = $SHELL
  let g:neoterm_autoinsert    = 1
  let g:neoterm_autoscroll    = 1

  nnoremap <silent> <leader>t :Ttoggle<CR>
endif

" the /g flag on :s substitutions by default
set gdefault

" ----------------------------------------------------------------------
" Startify
" ----------------------------------------------------------------------

let g:startify_enable_special         = 0
let g:startify_files_number           = 10
let g:startify_relative_path          = 1
let g:startify_change_to_dir          = 0
let g:startify_update_oldfiles        = 1
let g:startify_session_delete_buffers = 0

let g:startify_skiplist = [
      \ 'COMMIT_EDITMSG',
      \ '~/.config/nvim/init.vim'
      \ ]

let g:startify_bookmarks = [
      \ '~/.config/nvim/init.vim'
      \ ]

let g:startify_custom_footer =
      \ ['', "   Vim is charityware. Please read ':help uganda'.", '']

let g:startify_session_autoload     = 0
let g:startify_session_persistence  = 0

" Join lines with M
nn M J

" let g:ultisnips_inprogress = 0
"
" augroup amsaykUltisnips
"   autocmd!
"
"   func! s:CustomInnerKeyMapper()
"     let g:ultisnips_inprogress = 1
"   endfunc
"
"   func! s:CustomInnerKeyUnmapper()
"     let g:ultisnips_inprogress = 0
"   endfunc
"
"   autocmd! User UltiSnipsEnterFirstSnippet
"   autocmd User UltiSnipsEnterFirstSnippet call s:CustomInnerKeyMapper()
"   autocmd! User UltiSnipsExitLastSnippet
"   autocmd User UltiSnipsExitLastSnippet call s:CustomInnerKeyUnmapper()
"
"   func! g:TriggerNextCJ()
"     if g:ultisnips_inprogress
"       return "\<C-J>"
"     endif
"
"     return "\<C-O>j"
"   endfunction
"
"   func! g:TriggerNextCK()
"     if g:ultisnips_inprogress
"       return "\<C-K>"
"     endif
"
"     return "\<C-O>k"
"   endfunction
"
"   " Navigate ultisnips with c-j, c-k
"   inoremap <expr> <c-j> "<C-R>=g:TriggerNextCJ()<CR>"
"   " inoremap <expr> <c-k> "<C-R>=g:TriggerNextCK()<CR>"
" augroup END

" Navigate line with H L
nn H ^
nn L $

" Optimize
hi! NonText cterm=NONE ctermfg=NONE

" Typescript

" let g:typescript_compiler_binary  = 'tsc'
" let g:typescript_compiler_options = ''

" let g:typescript_indent_disable = 1

autocmd QuickFixCmdPost [^l]* nested cwindow
autocmd QuickFixCmdPost    l* nested lwindow

" autocmd FileType typescript JsPreTmpl html
" autocmd FileType typescript syn clear foldBraces  " For leafgarland/typescript-vim users only. Please see https://github.com/Quramy/vim-js-pretty-template/issues/1 for details.

" Flow

" let g:flow#enable    = 0
" let g:flow#errjmp    = 0
" let g:flow#autoclose = 1

" ----------------------------------------------------------------------------
" :Root | Change directory to the root of the Git repository
" ----------------------------------------------------------------------------
function! s:root()
  let root = systemlist('git rev-parse --show-toplevel')[0]
  if v:shell_error
    echo 'Not in git repo'
  else
    execute 'lcd' root
    echo 'Changed directory to: '.root
  endif
endfunction
command! Root call s:root()

" ----------------------------------------------------------------------------
" HL | Find out syntax group
" ----------------------------------------------------------------------------
function! s:hl()
  " ech  synIDattr(synID(line('.'), col('.'), 0), 'name')
  echo join(map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")'), '/')
endfunction
command! HL call <SID>hl()

" ----------------------------------------------------------------------------
" EX | chmod +x
" ----------------------------------------------------------------------------
command! EX if !empty(expand('%'))
         \|   write
         \|   call system('chmod +x '.expand('%'))
         \|   silent e
         \| else
         \|   echohl WarningMsg
         \|   echo 'Save the file first'
         \|   echohl None
         \| endif

" ----------------------------------------------------------------------------
" Profile
" ----------------------------------------------------------------------------
function! s:profile(bang)
  if a:bang
    profile pause
    noautocmd qall
  else
    profile start /tmp/profile.log
    profile func *
    profile file *
  endif
endfunction
command! -bang Profile call s:profile(<bang>0)

" Terminal mappings
if has('nvim')
  tnoremap <Esc> <C-\><C-n>

  tnoremap <silent> <M-h> <C-\><C-n>:TmuxNavigateLeft<CR>
  tnoremap <silent> <M-j> <C-\><C-n>:TmuxNavigateDown<CR>
  tnoremap <silent> <M-k> <C-\><C-n>:TmuxNavigateUp<CR>
  tnoremap <silent> <M-l> <C-\><C-n>:TmuxNavigateRight<CR>
  tnoremap <silent> <M-\> <C-\><C-n>:TmuxNavigatePrevious<CR>

  " Prefer Neovim terminal insert mode to normal mode.
  autocmd BufEnter,FocusGained term://* startinsert

  " Don't close terminal on :q
  autocmd TermOpen * set bufhidden=hide

  " Append --no-height
  " let $FZF_DEFAULT_OPTS .= ' --no-height' " https://github.com/neovim/neovim/issues/4151
endif

" Select pasted text
nnoremap <expr> gp '`[' . strpart(getregtype(), 0, 1) . '`]'

" Fix mixed indent
nnoremap <c-s>i :%retab!<CR>

" Vim-signiture
let g:SignatureMarkTextHLDynamic = 1

" the amount of space to use after the glyph character (default ' ')
let g:WebDevIconsNerdTreeAfterGlyphPadding = ''
let g:WebDevIconsNerdTreeGitPluginForceVAlign=0

let g:WebDevIconsOS = 'Darwin'

" Tweaks for browsing
" let g:netrw_banner = 0
" let g:netrw_browse_splits = 4
" let g:netrw_altv = 1
" let g:netrw_liststyle = 3
" let g:netrw_list_hide = netrw_gitignore#Hide()
" let g:netrw_list_hide .= ',\(^\|\s\s\)\zs\.\S\+'

nnoremap <silent> <c-n>e :Explore<cr>

" Stylefmt
" nnoremap <silent> <localleader>f :Stylefmt<CR>
" vnoremap <silent> <localleader>f :StylefmtVisual<CR>

" Sort motion
let g:sort_motion_flags = "u"

" French accents
" Note:  map! for Insert and Command-line, i.e. imap & cmap
"
map! ;Z À
map! ;G É
map! ;E Ê

map! ;z à
map! ;a â
map! ;b ä
map! ;c ç
map! ;d è
map! ;e ê
map! ;f ë
map! ;g é
map! ;i î
map! ;j ï
map! ;o ô
map! ;p ö
imap ;q «  »<Esc>hi
"         ^inserts within Quotations
map! ;t ù
map! ;u û
map! ;v ü

" Spelling stuff
" See: https://www.vim-fr.org/index.php/Correction_orthographique
map <silent> <F7> "<Esc>:silent setlocal spell! spelllang=en<CR>"
map <silent> <F8> "<Esc>:silent setlocal spell! spelllang=fr<CR>"

" Trigger a highlight in the appropriate direction when pressing these keys:
let g:qs_highlight_on_keys = ['f', 'F', 't', 'T']

if has("gui_running") || has('termguicolors') || has('nvim') " gui vim or vim enable TrueColor
  let g:qs_first_occurrence_highlight_color = '#ffffff'
  let g:qs_first_occurrence_highlight_bgcolor = '#CD0000'
  let g:qs_second_occurrence_highlight_color = '#ffffff'
  let g:qs_second_occurrence_highlight_bgcolor = '#447e27'
else " terminal vim
  let g:qs_first_occurrence_highlight_color = 15
  let g:qs_first_occurrence_highlight_bgcolor = 28
  let g:qs_first_occurrence_highlight_color = 15
  let g:qs_second_occurrence_highlight_bgcolor = 205
endif

" Ctrl click and drag for visual block mode
noremap <S-LeftMouse> <4-LeftMouse>
noremap <S-LeftDrag> <LeftDrag>

" Allows incsearch highlighting for range commands
" This is just a convenient shorthand of :/foobar/t.  :/foobar/m. and :/foobar/d
" use regular search to locate the line you want to
" Copy to current position
cnoremap $t <CR>:t''<CR>
" Move to current position
cnoremap $m <CR>:m''<CR>
" or Delete
cnoremap $d <CR>:d<CR>``

" CTRL-U in insert mode deletes a lot.  Use CTRL-G u to first break undo,
" so that you can undo CTRL-U after inserting a line break.
" inoremap <C-U> <C-G>u<C-U>

" close last open tag
imap <localleader>/ </<C-x><C-o>

" Duplicate line
nn <leader>D "xyy"xp

" last typed word to lower case
inoremap <C-g>u <esc>guawA

" last typed word to UPPER CASE
inoremap <C-g>~ <esc>gUawA

" entire line to lower case
" inoremap <C-g>u <esc>guuA

" entire line to UPPER CASE
inoremap <C-g>U <esc>gUUA

" last word to title case
" inoremap <C-w>t <esc>bvgU<esc>A

" current line to title case
inoremap <C-g>t <esc>:s/\v<(.)(\w*)/\u\1\L\2/g<cr>A

" =====================================
"  FZF
" =====================================
let g:fzf_history_dir = '~/.local/share/fzf-history'

nnoremap <leader>. :Tags<CR>
nnoremap <leader>b :Buffers<CR>
nnoremap <C-g>c :Commands<CR>
nnoremap <C-f>l :BLines<CR>
vnoremap <C-f>l :<C-u>BLines <c-r>=autocmds#escape_pattern(autocmds#get_visual_selection())<CR>
nnoremap <C-p> :Files<CR>
nnoremap <leader><C-p> :History<CR>
nnoremap <leader>M :Marks<CR>

autocmd! FileType fzf tnoremap <buffer> <esc> <c-c>

inoremap <c-c> <ESC>

function! s:yank_list()
  return reverse([
        \ '0 ' . @0,
        \ '1 ' . @1,
        \ '2 ' . @2,
        \ '3 ' . @3,
        \ '4 ' . @4,
        \ '5 ' . @5,
        \ '6 ' . @6,
        \ '7 ' . @7,
        \ '8 ' . @8,
        \ '9 ' . @9
        \ ])
endfunction

function! s:yank_handler(reg)
  if empty(a:reg)
    echo "aborted register paste"
  else
    let token = split(a:reg, ' ')
    execute 'normal! "' . token[0] . 'p'
  endif
endfunction

command! FZFYank call fzf#run({
      \ 'source': <sid>yank_list(),
      \ 'sink': function('<sid>yank_handler'),
      \ 'options': '-m',
      \ 'down': 12
      \ })

nmap <localleader>y :FZFYank<CR>

" let g:rg_command = '
"   \ rg --column --line-number --no-heading --fixed-strings --ignore-case --hidden --follow --color "always"
"   \ -g "*.{js,ts,json,php,md,styl,css,scss,less,jade,html,xml,config,py,cpp,c,go,hs,rb,conf,java,scala,rs,nim,swift}"
"   \ --files
"   \ -g "!.git/*"
"   \ -g "!node_modules/*"
"   \ -g "!vendor/*" '
"
" command! -bang -nargs=* F call fzf#vim#grep(g:rg_command .shellescape(<q-args>), 1, {'options': '--delimiter : --nth 4..'}, <bang>0)

nnoremap <C-g>/ :Rg<CR>

" Insert Mode:
imap <c-x><c-k> <plug>(fzf-complete-word)
imap <c-x><c-f> <plug>(fzf-complete-path)
imap <c-x><c-j> <plug>(fzf-complete-file-ag)
imap <c-x><c-l> <plug>(fzf-complete-line)

" Format rust code after save
let g:rustfmt_autosave = 1

" use this to add airline plugin if airline rtp load is disabled
let g:airline#extensions#cm_call_signature#enabled = 1

" let g:LanguageClient_serverCommands = {
"       \ 'cpp'            : ['cquery', '--language-server', '--log-file=/tmp/cq.log'],
"       \ 'dart'           : ['dart_language_server'],
"       \ 'rust'           : ['rustup', 'run', 'stable', 'rls'],
"       \ 'typescript'     : ['typescript-language-server', '--stdio'],
"       \ 'javascript'     : ['flow-language-server', '--stdio'],
"       \ 'javascript.jsx' : ['flow-language-server', '--stdio'],
"       \ 'go'             : ['go-langserver'],
"       \ }

" " Automatically start language servers.
" let g:LanguageClient_autoStart = 1
" let g:LanguageClient_diagnosticsList = 'Quickfix'
" let g:LanguageClient_changeThrottle = 0.5
" "let g:LanguageClient_settingsPath = expand('~/.config/nvim/settings.json')
" let g:LanguageClient_rootMarkers = {
"      \ 'cpp': ['.cquery', 'compile_commands.json', 'build'],
"      \ }


" Formatting

" augroup MyAutoformatCmds
"   autocmd!
"
"   autocmd BufWrite *.hs :Autoformat
"
"   " Scala
"   let g:formatdef_scalafmt = "'scalafmt_ng --config ~/Code/deviceident/.scalafmt.conf --stdin'"
"   let g:formatters_scala = ['scalafmt']
"   autocmd FileType scala noremap <buffer> <leader>f :Autoformat <BAR> update<CR>
"   autocmd BufWritePre *.{scala,sbt} :keepjumps Autoformat <BAR> update<CR> " Autoformat scala and sbt on save
"
"   " Prettier for js, typescript and flow
"   let g:formatdef_prettier = "'prettier --stdin --parser flow --tab-width 2 --print-width 81 --single-quote --trailing-comma all'"
"   let g:formatdef_prettierjson = "'prettier --stdin --parser json --tab-width 2 --print-width 81 --single-quote --trailing-comma all'"
"   let g:formatdef_prettiergraphql = "'prettier --stdin --parser graphql --tab-width 2 --print-width 81 --single-quote --trailing-comma all'"
"   let g:formatdef_prettierscss = "'prettier --stdin --parser postcss --tab-width 2 --print-width 81 --single-quote --trailing-comma all'"
"
"   let g:formatters_javascript = ['prettier']
"   " let g:formatters_typescript = ['prettier']
"   let g:formatters_json = ['prettierjson']
"   let g:formatters_graphql = ['prettiergraphql']
"   let g:formatters_scss = ['prettierscss']
"
"   function! DoFormatAndCleanHL()
"     let l:pos=getcurpos()
"     let l:search=@/
"     :keepjumps Autoformat
"     " :keepjumps %s/\V\"/'/e  " Undo prettier using double quotes on jsx attributes
"     let @/=l:search
"     " nohlsearch
"     call setpos('.', l:pos)
"   endfunction
"
"   " Don't automatically indent on save, since vim's autoindent for haskell is buggy
"   autocmd FileType haskell let b:autoformat_autoindent=0
"
"   " autocmd FileType javascript,javascript.jsx,typescript noremap <buffer> <leader>f :call DoFormatAndCleanHL()<CR>
"   " autocmd BufWritePre *.{js,ts} call DoFormatAndCleanHL()  --config $PWD/.scalafmt.conf" Autoformat on save
"
"   " autocmd FileType css,scss,sass,json,graphql noremap <buffer> <leader>f :keepjumps Autoformat<CR>
"   " autocmd BufWritePre *.{css,scss,json,graphql} :keepjumps Autoformat " Autoformat on save
"
"   " let g:ale_fixers = {
"   "       \  'javascript': ['prettier_standard'],
"   "       \ 'javascript.jsx': ['prettier_standard']
"   "       \ }
"   " let g:ale_linters = {
"   "       \ 'javascript': [''],
"   "       \ 'javascript.jsx': ['']
"   "       \ }
"   " let g:ale_fix_on_save = 1
"
"   let g:autoformat_autoindent = 0
"   let g:autoformat_retab = 0
"   let g:autoformat_remove_trailing_spaces = 0
" augroup END

if has('gui')
  set guioptions-=m  "remove menu bar
  set guioptions-=T  "remove toolbar
  set guioptions-=r  "remove right-hand scroll bar
  set guioptions-=L  "remove left-hand scroll bar
  set guioptions-=R
  set guioptions-=b
  set guioptions-=l
endif

" Don't wake up system with blinking cursor:
" http://www.linuxpowertop.org/known.php
let &guicursor = &guicursor . ",a:blinkon0"

" A black background would be better for remote terminal
" due to the low FPS
" hi Normal ctermbg=none

let g:paste_char_threshold = 3

call tweak#enhance_jumps#init()
nnoremap <silent> g<c-o> :call tweak#enhance_jumps#buffer_c_o()<CR>
" nnoremap <silent> g<F6> :call tweak#enhance_jumps#buffer_c_i()<CR>

" ` is more precise than '
noremap ' `

" do not override the register after paste in select mode
xnoremap <expr> p 'pgv"'.v:register.'y`>

if has('nvim')
  set shada='100"50
endif

" like emacs mode shell command editing
inoremap <C-E> <C-o>$
inoremap <C-Q> <C-o>^
inoremap <C-B> <left>
inoremap <C-F> <right>
inoremap <C-D> <Delete>

" command line editing
cnoremap <C-A>      <Home>
cnoremap <C-B>      <Left>
cnoremap <C-D>      <Delete>
" <C-F>  is also used for open  normal command-line editing. So if the
" cursor is at the end of the command-line, open normal command-line
" editing, otherwise move the cursor one character right.
cnoremap <expr> <C-F>  (getcmdpos()<(len(getcmdline())+1)) && (getcmdtype()==":") ?  "\<Right>" : "\<C-F>"
" already well mapped by default:
" <C-P> <Up>
" <C-N> <Down>
" <C-E> <End>

" not working?
snoremap <BS> <BS>i

augroup filetypedetect
  autocmd BufNewFile,BufRead .tmux.conf*,tmux.conf* setf tmux
  autocmd BufNewFile,BufRead .nginx.conf*,nginx.conf*,sites-available/*,sites-enabled/*,conf.d/*,*/nginx/config setf nginx
augroup END

" Ensime
" let g:ensime_server_v2=1

" Same when moving up and down
noremap <C-d> <C-d>zz
noremap <C-u> <C-u>zz

" Expand region

let g:expand_region_use_select_mode = 1

" Extend the global defaul
let g:expand_region_text_objects = {
      \ 'iw'  : 0,
      \ 'iW'  : 0,
      \ 'i"'  : 0,
      \ 'i''' : 0,
      \ 'i]'  : 1,
      \ 'ib'  : 1,
      \ 'iB'  : 1,
      \ 'il'  : 0,
      \ 'ip'  : 0,
      \ 'ie'  : 0,
      \ 'a]'  : 1,
      \ 'ab'  : 1,
      \ 'aB'  : 1,
      \ 'ii'  : 0,
      \ 'ai'  : 0,
      \ }

" Arg wrap
nnoremap <silent> J :ArgWrap<CR>

augroup MyArgWrapCmds
  au!
  au FileType javascript,javascript.jsx let b:argwrap_tail_comma = 1
  au FileType javascript,javascript.jsx let b:argwrap_padded_braces = '[{'
  au FileType javascript,javascript.jsx let b:argwrap_tail_comma_braces = '[{'
augroup END

" Tmux Navigation

let g:tmux_navigator_no_mappings = 1

" Write all buffers before navigating from Vim to tmux pane
let g:tmux_navigator_save_on_switch = 2

noremap <silent> <M-h> :TmuxNavigateLeft<CR>
noremap <silent> <M-j> :TmuxNavigateDown<CR>
noremap <silent> <M-k> :TmuxNavigateUp<CR>
noremap <silent> <M-l> :TmuxNavigateRight<CR>
noremap <silent> <M-\> :TmuxNavigatePrevious<CR>

nn <localleader><localleader> :Startify<CR>

" Jump to anywhere you want with minimal keystrokes, with just one key binding.
" `s{char}{label}`
" nmap f <Plug>(easymotion-overwin-f2)

nnoremap <Left> :vertical resize -1<CR>
nnoremap <Right> :vertical resize +1<CR>
nnoremap <Up> :resize -1<CR>
nnoremap <Down> :resize +1<CR>
" Disable arrow keys completely in Insert Mode
imap <up> <nop>
imap <down> <nop>
imap <left> <nop>
imap <right> <nop>

" move to the position where the last change was made
noremap gI `.

" change cursor to vertical bar in insert mode when using iTerm2
if $TERM_PROGRAM == 'iTerm.app'
  if exists('$TMUX')
    let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"
    let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
  else
    let &t_SI = "\<Esc>]50;CursorShape=1\x7"
    let &t_EI = "\<Esc>]50;CursorShape=0\x7"
  endif
endif

" Echodoc
set noshowmode

" === echodoc === "
" Enable echodoc on startup
let g:echodoc#enable_at_startup = 1
let g:echodoc#type = 'floating'
" To use a custom highlight for the float window,
" change Pmenu to your highlight group
highlight link EchoDocFloat Pmenu

" Dart

let g:dart_style_guide = 2
" let dart_format_on_save = 1

" Dirvish

augroup dirvish_config
  autocmd!
  autocmd FileType dirvish silent! unmap <buffer> <C-p>
  autocmd FileType dirvish silent! unmap <buffer> <C-n>
augroup END

let g:dirvish_git_indicators = {
      \ 'Modified'  : '✹',
      \ 'Staged'    : '✚',
      \ 'Untracked' : '✭',
      \ 'Renamed'   : '➜',
      \ 'Unmerged'  : '═',
      \ 'Ignored'   : '☒',
      \ 'Unknown'   : '?'
      \ }

" Wiki

" let g:vimwiki_list = [
"       \ { 'path' : '~/Dropbox/Wiki' }
"       \ ]

" Vim bookmarks
let g:bookmark_no_default_key_mappings = 1

nmap <localleader>mm <Plug>BookmarkToggle
nmap <localleader>mi <Plug>BookmarkAnnotate
nmap <localleader>ma <Plug>BookmarkShowAll
nmap <localleader>mj <Plug>BookmarkNext
nmap <localleader>mk <Plug>BookmarkPrev
nmap <localleader>mc <Plug>BookmarkClear
nmap <localleader>mx <Plug>BookmarkClearAll
nmap <localleader>mK <Plug>BookmarkMoveUp
nmap <localleader>mJ <Plug>BookmarkMoveDown
nmap <localleader>mg <Plug>BookmarkMoveToLine

" Far

" let g:far#source = "agnvim"

" vim-scala
au BufRead,BufNewFile *.sbt set filetype=scala

" coc.vim

" Use `[c` and `]c` for navigate diagnostics
nmap <silent> [c <Plug>(coc-diagnostic-prev)
nmap <silent> ]c <Plug>(coc-diagnostic-next)

" Remap keys for gotos
nmap <silent> <C-]> <Plug>(coc-definition)
nmap <silent> gy <Plug>(coc-type-definition)
nmap <silent> gi <Plug>(coc-implementation)
nmap <silent> <localleader>gr <Plug>(coc-references)

" Remap for do codeAction of current line
nmap <leader>ac <Plug>(coc-codeaction)

" Remap for do action format
nnoremap <silent> gF :call CocAction('format')<CR>

" Use K for show documentation in preview window
nnoremap <silent> K :call <SID>show_documentation()<CR>

function! s:show_documentation()
  if &filetype == 'vim'
    execute 'h '.expand('<cword>')
  else
    call CocActionAsync('doHover')
  endif
endfunction

" Highlight symbol under cursor on CursorHold
autocmd CursorHold * silent call CocActionAsync('highlight')

" Use <C-l> for trigger snippet expand.
imap <C-l> <Plug>(coc-snippets-expand)

" Use <C-j> for select text for visual placeholder of snippet.
vmap <C-j> <Plug>(coc-snippets-select)

" Use <C-j> for jump to next placeholder, it's default of coc.nvim
let g:coc_snippet_next = '<Tab>'

" Use <C-k> for jump to previous placeholder, it's default of coc.nvim
let g:coc_snippet_prev = '<S-Tab>'

" Use <C-j> for both expand and jump (make expand higher priority.)
imap <C-j> <Plug>(coc-snippets-expand-jump)

" Remap for rename current word
nmap <localleader>rn <Plug>(coc-rename)

" Show all diagnostics
nnoremap <silent> <localleader>a  :<C-u>CocList diagnostics<cr>
" Find symbol of current document
nnoremap <silent> <localleader>o  :<C-u>CocList outline<cr>
" Search workspace symbols
nnoremap <silent> <localleader>s  :<C-u>CocList -I symbols<cr>
nnoremap <silent> <c-\>  :<C-u>CocList -I symbols<cr>
" Do default action for next item.
nnoremap <silent> <localleader>j  :<C-u>CocNext<CR>
" Do default action for previous item.
nnoremap <silent> <localleader>k  :<C-u>CocPrev<CR>
" Resume latest coc list
nnoremap <silent> <localleader>p  :<C-u>CocListResume<CR>

nmap <localleader>de <Plug>(coc-metals-expand-decoration)

" Toggle panel with Tree Views
nnoremap <silent> <space>ta :<C-u>CocCommand metals.tvp<CR>
" Toggle Tree View 'metalsBuild'
nnoremap <silent> <space>tb :<C-u>CocCommand metals.tvp metalsBuild<CR>
" Toggle Tree View 'metalsCompile'
nnoremap <silent> <space>tc :<C-u>CocCommand metals.tvp metalsCompile<CR>
" Reveal current current class (trait or object) in Tree View 'metalsBuild'
nnoremap <silent> <space>tf :<C-u>CocCommand metals.revealInTreeView metalsBuild<CR>

" list of the extensions required
let g:coc_global_extensions = [
      \'coc-highlight',
      \'coc-yank',
      \'coc-json',
      \'coc-css',
      \'coc-html',
      \'coc-tsserver',
      \'coc-yaml',
      \'coc-lists',
      \'coc-syntax'
      \]

" Metals specific commands
" Start Metals Doctor
command! -nargs=0 MetalsDoctor :call CocRequestAsync('metals', 'workspace/executeCommand', { 'command': 'doctor-run' })
" Manually start build import
command! -nargs=0 MetalsImport :call CocRequestAsync('metals', 'workspace/executeCommand', { 'command': 'build-import' })
" Manually connect with the build server
command! -nargs=0 MetalsConnect :call CocRequestAsync('metals', 'workspace/executeCommand', { 'command': 'build-connect' })

augroup MyCocSetup
  autocmd!
  " Update signature help on jump placeholder
  autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
augroup end

autocmd FileType json syntax match Comment +\/\/.\+$+

" use <c-space>for trigger completion
inoremap <silent><expr> <c-space> coc#refresh()

inoremap <expr> <Tab> pumvisible() ? "\<C-n>" : "\<Tab>"
inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"

inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"
" Use tab for trigger completion with characters ahead and navigate.
" Use command ':verbose imap <tab>' to make sure tab is not mapped by other plugin.
inoremap <silent><expr> <TAB>
      \ pumvisible() ? "\<C-n>" :
      \ coc#expandableOrJumpable() ? coc#rpc#request('doKeymap', ['snippets-expand-jump','']) :
      \ <SID>check_back_space() ? "\<TAB>" :
      \ coc#refresh()

function! s:check_back_space() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfunction

" coc.nvim color changes
hi! link CocErrorSign ErrorMsg
hi! link CocWarningSign Number
hi! link CocInfoSign Type
hi! default CocHighlightText guifg=green gui=bold

" Make background transparent for many things
" hi! Normal ctermbg=NONE guibg=NONE
hi! NonText ctermbg=NONE guibg=NONE
hi! LineNr ctermfg=NONE guibg=NONE
hi! SignColumn ctermfg=NONE guibg=NONE
hi! StatusLine guifg=#16252b guibg=#6699CC
hi! StatusLineNC guifg=#16252b guibg=#16252b

" Wrap in try/catch to avoid errors on initial install before plugin is available
try

" Vim airline theme
" let g:airline_theme='space'

" === Vim airline ==== "
" Enable extensions
" let g:airline_extensions = ['branch', 'hunks', 'coc']
let g:airline_extensions = ['branch', 'coc']

" Update section z to just have line number
let g:airline_section_z = airline#section#create(['linenr'])

" Do not draw separators for empty sections (only for the active window) >
let g:airline_skip_empty_sections = 1

" Smartly uniquify buffers names with similar filename, suppressing common parts of paths.
let g:airline#extensions#tabline#formatter = 'unique_tail'

" Custom setup that removes filetype/whitespace from default vim airline bar
let g:airline#extensions#default#layout = [['a', 'b', 'c'], ['x', 'z', 'warning', 'error']]

let g:airline#extensions#coc#enabled = 1
let airline#extensions#coc#error_symbol = 'E:'
let airline#extensions#coc#warning_symbol = 'W:'
let airline#extensions#coc#stl_format_err = '%E{[%e(#%fe)]}'
let airline#extensions#coc#stl_format_warn = '%W{[%w(#%fw)]}'

" Configure error/warning section to use coc.nvim
let g:airline_section_error = '%{airline#util#wrap(airline#extensions#coc#get_error(),0)}'
let g:airline_section_warning = '%{airline#util#wrap(airline#extensions#coc#get_warning(),0)}'

function! CocExtensionStatus() abort
  return get(g:, 'coc_status', '')
endfunction
let g:airline_section_c = '%f%{CocExtensionStatus()}'

" Disable vim-airline in preview mode
let g:airline_exclude_preview = 1

" let g:airline_symbols.space = "\ua0"

" let g:airline#extensions#whitespace#enabled = 1

" let g:airline_symbols.maxlinenr = ''

" let g:airline_symbols.linenr = 'ℓ'

" let g:airline_skip_empty_sections = 1

" Enable powerline fonts
let g:airline_powerline_fonts = 1

" Enable caching of syntax highlighting groups
let g:airline_highlighting_cache = 1

" Define custom airline symbols
if !exists('g:airline_symbols')
  let g:airline_symbols = {}
endif

" unicode symbols
let g:airline_left_sep = '❮'
let g:airline_right_sep = '❯'

" Don't show git changes to current file in airline
let g:airline#extensions#hunks#enabled=0

catch
  echo 'Airline not installed. It should work after running :PlugInstall'
endtry

" Try to hide vertical spit and end of buffer symbol
" hi! VertSplit gui=NONE guifg=#17252c guibg=#17252c
" hi! EndOfBuffer ctermbg=NONE ctermfg=NONE guibg=#17252c guifg=#17252c

" vim-lsc
" let g:lsc_reference_highlights = v:false
" let g:lsc_enable_autocomplete = v:false
" let g:lsc_server_commands = {
"   \ 'scala': 'metals-vim'
"   \}
" let g:lsc_auto_map = {
"   \ 'GoToDefinition': '<C-]>',
"   \ 'FindReferences': 'gF',
"   \ 'NextReference': 'g<C-n>',
"   \ 'PreviousReference': 'g<C-p>',
"   \ 'Rename': 'gR',
"   \ 'FindImplementations': 'gI',
"   \ 'FindCodeActions': 'ga',
"   \ 'DocumentSymbol': 'go',
"   \ 'WorkspaceSymbol': 'gS',
"   \ 'ShowHover': 'v:true',
"   \ 'SignatureHelp': 'g<C-m>',
"   \ 'Completion': 'completefunc',
"   \}
"
" hi lscDiagnosticError gui=underline guifg=#8b0000
" hi lscDiagnosticWarning gui=underline guifg=#ff4500

nnoremap [g :set nohls<CR>/<<<<<<<<CR>:set hls<CR>
nnoremap ]g :set nohls<CR>?<<<<<<<<CR>:set hls<CR>
nnoremap [= :set nohls<CR>/=======<CR>:set hls<CR>
nnoremap ]= :set nohls<CR>/=======<CR>:set hls<CR>
nnoremap [G :set nohls<CR>?>>>>>>><CR>:set hls<CR>
nnoremap ]G :set nohls<CR>?>>>>>>><CR>:set hls<CR>

" highlight BookmarkSign ctermbg=whatever ctermfg=whatever
" highlight BookmarkAnnotationSign ctermbg=whatever ctermfg=whatever
" highlight BookmarkLine ctermbg=whatever ctermfg=whatever
" highlight BookmarkAnnotationLine ctermbg=whatever ctermfg=whatever

" let g:timer = timer_start(300000, 'Pomodoro', {'repeat':-1})
" let g:value = 0
" function! Pomodoro(timer)
"   let g:value += 1
"   if g:value == 5
"     call Beep()
"     echo 'take a break!'
"   endif
" endfunction
" function! Beep()
"   let [l:vb, l:eb]  = [&vb, &eb]
"   set vb eb
"   call feedkeys("\<esc>", 'x')
"   let [&vb, &eb] = [l:vb, l:eb]
" endfunction

" Let's have some fun with the QuickFix window
autocmd BufReadPost quickfix setlocal foldmethod=expr
autocmd BufReadPost quickfix setlocal foldexpr=or(getline(v:lnum)[0:1]=='\|\|')
autocmd BufReadPost quickfix setlocal foldlevel=0

" Haskell - hident
let g:hindent_on_save = 1

" Terminal buffer options for fzf
" autocmd! FileType fzf
autocmd  FileType fzf set noshowmode noruler nonu

"" FZF

" general
let g:fzf_layout = { 'window': 'call CreateCenteredFloatingWindow()' }
let $FZF_DEFAULT_OPTS="--reverse " " top to bottom

" floating fzf window with borders
function! CreateCenteredFloatingWindow()
    let width = min([&columns - 4, max([80, &columns - 20])])
    let height = min([&lines - 4, max([20, &lines - 10])])
    let top = ((&lines - height) / 2) - 1
    let left = (&columns - width) / 2
    let opts = {'relative': 'editor', 'row': top, 'col': left, 'width': width, 'height': height, 'style': 'minimal'}

    let top = "╭" . repeat("─", width - 2) . "╮"
    let mid = "│" . repeat(" ", width - 2) . "│"
    let bot = "╰" . repeat("─", width - 2) . "╯"
    let lines = [top] + repeat([mid], height - 2) + [bot]
    let s:buf = nvim_create_buf(v:false, v:true)
    call nvim_buf_set_lines(s:buf, 0, -1, v:true, lines)
    call nvim_open_win(s:buf, v:true, opts)
    " set winhl=Normal:Floating
    let opts.row += 1
    let opts.height -= 2
    let opts.col += 2
    let opts.width -= 4
    call nvim_open_win(nvim_create_buf(v:false, v:true), v:true, opts)
    au BufWipeout <buffer> exe 'bw '.s:buf
endfunction

" Files + devicons + floating fzf
function! Fzf_dev()
  function! s:files()
    let l:files = split(system($FZF_DEFAULT_COMMAND), '\n')
    return s:prepend_icon(l:files)
  endfunction

  function! s:prepend_icon(candidates)
    let l:result = []
    for l:candidate in a:candidates
      let l:filename = fnamemodify(l:candidate, ':p:t')
      let l:icon = WebDevIconsGetFileTypeSymbol(l:filename, isdirectory(l:filename))
      call add(l:result, printf('%s %s', l:icon, l:candidate))
    endfor

    return l:result
  endfunction

  function! s:edit_file(item)
    let l:pos = stridx(a:item, ' ')
    let l:file_path = a:item[pos+1:-1]
    execute 'silent e' l:file_path
  endfunction

  call fzf#run({
        \ 'source': <sid>files(),
        \ 'sink':   function('s:edit_file'),
        \ 'options': '-m --reverse ',
        \ 'down':    '40%',
        \ 'window': 'call CreateCenteredFloatingWindow()'})

endfunction

function! s:IsFirenvimActive(event) abort
  if !exists('*nvim_get_chan_info')
    return 0
  endif
  let l:ui = nvim_get_chan_info(a:event.chan)
  return has_key(l:ui, 'client') && has_key(l:ui.client, "name") &&
      \ l:ui.client.name is# "Firenvim"
endfunction

function! OnUIEnter(event) abort
  if s:IsFirenvimActive(a:event)
    set laststatus=0

    let g:dont_write = v:false
    function! My_Write(timer) abort
      let g:dont_write = v:false
      write
    endfunction

    function! Delay_My_Write() abort
      if g:dont_write
        return
      end
      let g:dont_write = v:true
      call timer_start(10000, 'My_Write')
    endfunction

    au TextChanged * ++nested call Delay_My_Write()
    au TextChangedI * ++nested call Delay_My_Write()

  endif
endfunction
autocmd UIEnter * call OnUIEnter(deepcopy(v:event))

" let fc = g:firenvim_config['localSettings']
" let fc['.*'] = { 'takeover': 'never' }

" if has('nvim') && exists('&winblend') && &termguicolors
"   set winblend=10
"
"   hi NormalFloat guibg=None
"   if exists('g:fzf_colors.bg')
"     call remove(g:fzf_colors, 'bg')
"   endif
"
"   if stridx($FZF_DEFAULT_OPTS, '--border') == -1
"     let $FZF_DEFAULT_OPTS .= ' --border'
"   endif
"
"   let $FZF_DEFAULT_OPTS .= ' --layout=reverse'
"
"   function! FloatingFZF()
"     let buf = nvim_create_buf(v:false, v:true)
"     call setbufvar(buf, '&signcolumn', 'no')
"
"     call OpenPaddedFloating(buf)
"   endfunction
"
"   let s:intreg = '\v^\d+$'
"   let s:percentreg = '\v^(\d+)(\%$)@='
"
"   fu! g:OpenPaddedFloating(buffer, ...)
"     let l:buf = a:buffer =~ s:intreg ? +a:buffer : bufnr(a:buffer)
"     let l:pad_x = 7 | let l:pad_y = 7
"     let l:err = 'OpenPaddedFloating: invalid arguments: ' . string(a:000)
"
"     if len(a:000) == 1
"       if a:000[0] =~ s:intreg
"         let l:pad_x = +a:000[0]
"         let l:pad_y = l:pad_x
"       elsei a:000[0] =~ s:percentreg
"         let l:percent = 100 - matchstr(a:000[0], s:percentreg)
"         let l:pad_x = &co    - (&co    * l:percent / 100)
"         let l:pad_y = &lines - (&lines * l:percent / 100)
"         let l:pad_x = l:pad_x / 2
"         let l:pad_y = l:pad_y / 2
"       el | th l:err | en
"     elsei len(a:000) == 2
"       if (a:000[0] =~ s:intreg || a:000[0] =~ s:percentreg)
"             \ && (a:000[1] =~ s:intreg || a:000[1] =~ s:percentreg)
"         if a:000[0] =~ s:intreg
"           let l:pad_x = +a:000[0]
"         elsei a:000[0] =~ s:percentreg
"           let l:percent_x = 100 - matchstr(a:000[0], s:percentreg)
"           let l:pad_x = &co - (&co * l:percent_x / 100)
"           let l:pad_x = l:pad_x / 2
"         en
"         if a:000[1] =~ s:intreg
"           let l:pad_y = +a:000[1]
"         elsei a:000[1] =~ s:percentreg
"           let l:percent_y = 100 - matchstr(a:000[1], s:percentreg)
"           let l:pad_y = &lines - (&lines * l:percent_y / 100)
"           let l:pad_y = l:pad_y / 2
"         en
"       el | th l:err | en
"     elsei len(a:000) != 0 | th l:err | en
"
"     retu nvim_open_win(l:buf, v:true, {
"           \ 'relative': 'editor',
"           \ 'width':    &co    - (l:pad_x * 2),
"           \ 'height':   &lines - (l:pad_y * 2),
"           \ 'col':      l:pad_x,
"           \ 'row':      l:pad_y,
"           \})
"   endf
"
"   let g:fzf_layout = { 'window': 'call FloatingFZF()' }
" endif

" ----------------------------------------------------------------------
"  Local Settings                                                     |
" ----------------------------------------------------------------------

" Load local settings if they exist.
"
" [!] The following needs to remain at the end of this file in
"     order to allow any of the above settings to be overwritten
"     by the local ones.

if filereadable(glob('~/.vimrc.local'))
  source ~/.vimrc.local
endif

